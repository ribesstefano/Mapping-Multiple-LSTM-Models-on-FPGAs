# HLS SVD

## Overview

This project includes the HLS implementation and the approximation algorithms included in the paper "Mapping Multiple LSTM models on FPGA".

### SVD Approximation Algorithm

The bot AI is trained in Google Colab following the notebook in `ai/` folder.

### Hardware

The hardware part was implemented in Vivado High Level Synthesis (HLS) C++. It exploits Xilinx OpenCV libraries for resizing and stream the video frames generated by the game.

#### Pong Game Cosimulation

#### OpenCV Cosimulation

#### HDMI Modules

For instantiating the HDMI IPs, please follow this [guide](https://forums.xilinx.com/t5/Design-and-Debug-Techniques-Blog/Video-Series-23-Generate-a-video-output-on-Pynq-Z2-HDMI-out/ba-p/932553).

#### Vivado Project

## Requirements

* CMake
* Xilinx Vivado 2018.3

### CMake Simulation

#### Windows

Simulation is working assuming the Xilinx OpenCV DLLs are copied into the `bin/` folder along side with the generated executables.
```
"C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\vcvarsall.bat" amd64
mkdir build
cmake .. -G Ninja
cmake --build . --config Release
```

#### Linux
```
mkdir build
cd build
cmake ..
make all
```

## Notes on Using Vitis

### Implementing AXIS Interfaces

In order to implement AXIS interfaces, avoid using `depth` in the pragma, as follows:
```c++
const int kAxiBitwidth = 128;

void HlsVectorKernelU_V2(hls::stream<ap_axiu<kAxiBitwidth, 0, 0, 0> >& x_port,
  											 hls::stream<ap_axiu<kAxiBitwidth, 0, 0, 0> >& y_port) {
#pragma HLS INTERFACE axis port=x_port // depth=... <- NO DEPTH!
#pragma HLS INTERFACE axis port=y_port // depth=... <- NO DEPTH!
	// ...
}
```
The type `ap_axiu` must now be used to generate AXIS with side channels. Note: for using external DMAs, we just need the TLAST signal.

The `AxiStreamInterface` class in `axis_lib.h` can also be used with `hls::vector` types, like:

```c++
const int kAxiBitwidth = 128;

void HlsVectorKernelU_V2(hls::stream<ap_axiu<kAxiBitwidth, 0, 0, 0> >& x_port,
  											 hls::stream<ap_axiu<kAxiBitwidth, 0, 0, 0> >& y_port) {
#pragma HLS INTERFACE axis port=x_port // depth=... <- NO DEPTH!
#pragma HLS INTERFACE axis port=y_port // depth=... <- NO DEPTH!
  auto x_axis = svd::AxiStreamInterface<kAxiBitwidth>(x_port);
  auto y_axis = svd::AxiStreamInterface<kAxiBitwidth>(y_port);
  // ...
  auto x_vec = x_axis.PopVector<float, 4>(); // This will pop a float vector of 4 elements.
  // ...
  hls::vector<float, 4> y_vec(3.14);
  y_axis.PushVector<float, 4>(y_vec); // This will pop a float vector of 4 elements.
	// ...
}
```

### HLS Vector Patch

If the project will be compiled with the Vitis HLS libraries, it needs a patch in the `hls::vector` class.

Simply add the following line in the `vector` class after the `public:` statement:
```c++
public:
  static const int width = N;
```

In this way, one can access the number of elements in a `hls::vector` at compile/synthesis time by doing:

```c++
hls::vector<int, 5> a;
std::cout << "Number of elements in a: " << a::width << std::endl;

// > Number of elements in a: 5
```


## TODOs

List of TODOs:
	* ~Import u, s, v new kernels~
	* ~Import (and clean up?) u, s, v old kernels~
	* ~Import DMA functions~
	* ~Import and clean up HLS SVD-model-Bouganis~
	* ~Import and clean up HLS SVD-model-2LSTM~
	* ~Import some testbenches to try compile something~

## Bugs

List of possible bugs:
* Constructing data handler storage might lead to segmentation faults. More checks needed.